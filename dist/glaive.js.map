{"version":3,"file":"glaive.js","sources":["../lib/isType.js","../lib/sleep.js","../lib/allot.js","../lib/error.js","../lib/moduleStatus.js","../src/Injector.js","../src/Module.js","../src/Decorator.js","../src/index.js"],"sourcesContent":["export default new Proxy(\n  {},\n  {\n    get: (target, name) => value => {\n      const type = value::Object.prototype.toString().slice(8, -1)\n      return type[0].toLowerCase() + type.slice(1) === name\n    },\n  },\n)\n","export default async time =>\n  await new Promise(resolve => {\n    if (!time) {\n      resolve(true)\n    } else {\n      setTimeout(() => resolve(true), time)\n    }\n  })\n","export const prefix = \"_\"\nexport default function(config = {}) {\n  Object.entries(config)\n    .filter(([key]) => key !== \"allotParams\" && key !== \"complete\")\n    .map(([key, value]) => {\n      this[`${prefix}${key}`] = value\n    })\n  return this\n}\n","export const ERROR = {\n  allotParams: `\\'allotParams\\' must be a function`,\n  boot: `\\`Injector failed to boot up \\``,\n  module: `\\'module\\' must be a function or class`,\n}\n\nconst error = new Proxy(\n  {},\n  {\n    get: (target, name) => value => {\n      return ERROR[name] || `${value} Error`\n    },\n  },\n)\n\nexport default new Proxy(\n  {},\n  {\n    get: (target, name) => value => {\n      throw new Error(error[name](value))\n    },\n  },\n)\n","export default new Proxy(\n  {},\n  {\n    get: (target, name) => {\n      return new Map(\n        [\"initial\", \"initialized\", \"booting\", \"ready\"].map(i => [i, i]),\n      ).get(name)\n    },\n  },\n)\n","import is from \"../lib/isType\"\nimport sleep from \"../lib/sleep\"\nimport allot, { prefix } from \"../lib/allot\"\nimport error from \"../lib/error\"\nimport moduleStatus from \"../lib/moduleStatus\"\n\nexport default (\n  TargetModule = class {\n    constructor() {}\n  },\n) => {\n  return class Injector extends TargetModule {\n    constructor(config = {}) {\n      super(config)\n      const { allotParams = this._allotParams } = config\n      if (is.function(allotParams)) {\n        ;this::allotParams(config)\n      } else {\n        error.allotParams()\n      }\n      this._modules = new Map()\n      this._queueModules = new Set()\n      this._loadModulesHistory = new Set()\n      this._bootstrap(config).then(this::this._complete)\n    }\n\n    _allotParams(config) {\n      return this::allot(config)\n    }\n\n    _complete({ done }) {\n      this.initiated = true\n      return is.function(done) && done(this.initiated)\n    }\n\n    _merge(modules) {\n      let dependenceMap = []\n      modules.forEach(({ injectors } = {}, moduleName) => {\n        const dependence = injectors.reduce((pre, { deps = [] }) => {\n          return [...new Set(pre.concat(deps))]\n        }, [])\n        dependenceMap.push({\n          moduleName,\n          dependence,\n        })\n      })\n      return dependenceMap\n    }\n\n    _queue(modules = [], list) {\n      let restModules = []\n      modules.map(({ moduleName, dependence = [] } = {}) => {\n        const isNoneDependence = dependence.length === 0\n        const rest = [...new Set(dependence.concat([...list]))].filter(\n          item => ![...list].includes(item),\n        )\n        const isDepended = rest.length === 0\n        if (isNoneDependence || isDepended) {\n          list.add(moduleName)\n        } else {\n          restModules.push({ moduleName, dependence })\n        }\n      })\n      if (restModules.length > 0) {\n        this._queue(restModules, list)\n      }\n    }\n\n    _initialize(preDistribute) {\n      const dependenceMap = this._merge(this._modules)\n      this._queue(dependenceMap, this._queueModules)\n      this._queueModules.forEach(moduleName => {\n        const { Module, parameters, moduleKey, injectors } = this._modules.get(\n          moduleName,\n        )\n        if(preDistribute){\n          const dependences = new Set(\n            injectors.reduce((prev,{deps=[]})=>{\n              return [...prev,...deps]\n            },[])\n          )\n          const dependenceModules = {}\n          dependences.forEach((name)=>{\n            const {moduleKey} = this._modules.get(name)\n            dependenceModules[moduleKey] = this[moduleKey]\n          })\n          Object.assign(parameters,dependenceModules)\n        }\n        this[moduleKey] = new Module(parameters)\n        this.mountParams(moduleKey)\n        this[moduleKey].__status = moduleStatus.initialized\n      })\n      ;this::this.distribute(dependenceMap)\n      return this\n    }\n\n    _insureUnique() {\n      const overloadModules = [...this._loadModulesHistory].slice(0, -1)\n      overloadModules.forEach((modules = []) =>\n        modules.forEach(({ key, module }) => {\n          const isRemove =\n            this._modules.get(module.prototype.constructor.name).moduleKey !==\n            key\n          if (!is.null(key) && !is.undefined(key) && isRemove) {\n            Reflect.deleteProperty(this, key)\n          }\n        }),\n      )\n    }\n\n    mountParams() {\n      return this\n    }\n\n    inject(modules, { preInject, preDistribute } = {}) {\n      preInject && this::preInject()\n      modules.map(\n        ({ module, deps = [], params = {}, key, before, after } = {}) => {\n          if (!is.function(module)) {\n            return error.module()\n          }\n          const moduleName = module.prototype.constructor.name\n          const { _key = moduleName, _injectors = [] } = module\n          const moduleKey = key || _key\n          const originModule = this._modules.get(moduleName)\n          const { parameters = params, injectors = _injectors } =\n            originModule || {}\n          let override = {}\n          if (originModule) {\n            override = {\n              parameters: params,\n              injectors: [..._injectors, { deps, before, after }],\n            }\n          }\n          this._modules.set(\n            moduleName,\n            Object.assign(\n              {\n                Module: module,\n                moduleKey: moduleKey[0].toLowerCase() + moduleKey.slice(1),\n                parameters: Object.assign(parameters, params),\n                injectors: [...injectors, { deps, before, after }],\n              },\n              override,\n            ),\n          )\n        },\n      )\n      this._loadModulesHistory.add(modules)\n      this._initialize(preDistribute)\n      return this\n    }\n\n    distribute(dependenceMap) {\n      dependenceMap.map(({ moduleName, dependence }) => {\n        dependence.map(name => {\n          const { moduleKey } = this._modules.get(moduleName)\n          const module = this._modules.get(name)\n          this[moduleKey][`${prefix}${module.moduleKey}`] = this[\n            module.moduleKey\n          ]\n        })\n      })\n      return this\n    }\n\n    async _bootstrap(config) {\n      await sleep()\n      this._insureUnique()\n      try {\n        let queueModules = [...this._queueModules]\n        while (queueModules.length > 0) {\n          const moduleName = queueModules.shift()\n          const { injectors, moduleKey } = this._modules.get(moduleName)\n          if (!this[moduleKey]) {\n            error.throw(moduleKey)\n            continue\n          }\n          const isAsync = is.asyncFunction(this[moduleKey].initialize)\n          const _injectors = [...injectors]\n          this[moduleKey].__status = moduleStatus.booting\n          let beforeInjectors = _injectors.filter(({ before }) => before)\n          while (beforeInjectors.length > 0) {\n            let unprocessed\n            const { before, deps } = beforeInjectors.shift()\n            const isAsyncAction = is.asyncFunction(before)\n            const args = deps.map(dep => this[this._modules.get(dep).moduleKey])\n            if (isAsyncAction) {\n              unprocessed = await before(...args, this[moduleKey])\n            } else {\n              unprocessed = before(...args, this[moduleKey])\n            }\n          }\n          if (isAsync) {\n            await this[moduleKey].initialize()\n          } else {\n            if (is.function(this[moduleKey].initialize)) {\n              this[moduleKey].initialize()\n            }\n          }\n          let afterInjectors = _injectors.filter(({ after }) => after)\n          while (afterInjectors.length > 0) {\n            let processed\n            const { after, deps } = afterInjectors.shift()\n            const isAsyncAction = is.asyncFunction(after)\n            const args = deps.map(dep => this[this._modules.get(dep).moduleKey])\n            if (isAsyncAction) {\n              processed = await after(...args, this[moduleKey])\n            } else {\n              processed = after(...args, this[moduleKey])\n            }\n          }\n          this[moduleKey].__status = moduleStatus.ready\n        }\n      } catch (e) {\n        console.log(e)\n        error.boot()\n      }\n      return config\n    }\n  }\n}\n","import is from \"../lib/isType\"\nimport allot from \"../lib/allot\"\nimport error from \"../lib/error\"\nimport moduleStatus from \"../lib/moduleStatus\"\n\nexport default class Module {\n  constructor(args) {\n    const isFunction = is.function(this._allotParams)\n    if (isFunction) {\n      this._allotParams(args)\n    } else {\n      error.allotParams()\n    }\n    this.__status = moduleStatus.initial\n  }\n\n  _allotParams(config) {\n    return this::allot(config)\n  }\n}\n","export default (dependencies = {}) => target => {\n  target._injectors = [...(target._injectors || []), dependencies]\n  if (dependencies.key) {\n    target._key = dependencies.key\n  }\n}\n\n// export const prefix = '$$'\n// export const allot = (target, key, descriptor) => {\n//   const method = descriptor.value\n//   const allotParams = function(config = {}) {\n//     Object.entries(config)\n//       .filter(([key]) => key !== 'allotParams' && key !== 'complete')\n//       .map(([key, value]) => {\n//         this[`${prefix}${key}`] = value\n//       })\n//   }\n//   descriptor.value = (...args) => {\n//     const [config] = args\n//     return target::allotParams(config)\n//   }\n//   return descriptor\n// }\n","import Injector from \"./Injector\"\nimport Module from \"./Module\"\nimport Decorator from \"./Decorator\"\n\nexport default {\n  Injector,\n  Module,\n  Decorator,\n}\n\nexport { Injector, Module, Decorator }\n"],"names":["Proxy","target","name","type","Object","prototype","toString","slice","toLowerCase","time","Promise","resolve","prefix","config","entries","filter","key","map","value","ERROR","error","Error","Map","i","get","TargetModule","allotParams","_allotParams","is","function","_modules","_queueModules","Set","_loadModulesHistory","_bootstrap","then","_complete","allot","done","initiated","modules","dependenceMap","forEach","injectors","moduleName","dependence","reduce","pre","deps","concat","push","list","restModules","isNoneDependence","length","rest","includes","item","isDepended","add","_queue","preDistribute","_merge","Module","parameters","moduleKey","dependences","prev","dependenceModules","assign","mountParams","__status","moduleStatus","initialized","distribute","overloadModules","module","isRemove","constructor","null","undefined","deleteProperty","preInject","params","before","after","_key","_injectors","originModule","override","set","_initialize","sleep","_insureUnique","queueModules","shift","throw","isAsync","asyncFunction","initialize","booting","beforeInjectors","unprocessed","isAsyncAction","args","dep","afterInjectors","processed","ready","e","log","boot","isFunction","initial","dependencies"],"mappings":"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"}