!(function(a, b) {
  typeof exports === "object" && typeof module !== "undefined"
    ? b(exports)
    : typeof define === "function" && define.amd
      ? define(["exports"], b)
      : b((a.glaive = {}))
})(this, function(a) {
  "use strict"
  var b = new Proxy(
      {},
      {
        get: function c(a, b) {
          return function(a) {
            var c = Object.prototype.toString.call(a).slice(8, -1)
            return c[0].toLowerCase() + c.slice(1) === b
          }
        },
      },
    ),
    c = async function(a) {
      return await new Promise(function(b) {
        a
          ? setTimeout(function() {
              return b(!0)
            }, a)
          : b(!0)
      })
    },
    f = function(a, b) {
      if (!(a instanceof b)) {
        throw new TypeError("Cannot call a class as a function")
      }
    },
    g = (function() {
      function a(a, b) {
        for (var c = 0; c < b.length; c++) {
          var d = b[c]
          d.enumerable = d.enumerable || !1
          d.configurable = !0
          "value" in d && (d.writable = !0)
          Object.defineProperty(a, d.key, d)
        }
      }
      return function(b, c, d) {
        c && a(b.prototype, c)
        d && a(b, d)
        return b
      }
    })(),
    h = (function() {
      function a(a, b) {
        var c = [],
          d = !0,
          e = !1,
          f = undefined
        try {
          for (
            var g = a[Symbol.iterator](), h;
            !(d = (h = g.next()).done);
            d = !0
          ) {
            c.push(h.value)
            if (b && c.length === b) break
          }
        } catch (a) {
          ;(e = !0), (f = a)
        } finally {
          try {
            !d && g["return"] && g["return"]()
          } finally {
            if (e) throw f
          }
        }
        return c
      }
      return function(b, c) {
        if (Array.isArray(b)) {
          return b
        } else if (Symbol.iterator in Object(b)) {
          return a(b, c)
        } else {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance",
          )
        }
      }
    })(),
    j = function(a) {
      if (Array.isArray(a)) {
        for (var b = 0, c = Array(a.length); b < a.length; b++) c[b] = a[b]
        return c
      } else {
        return Array.from(a)
      }
    },
    k = "_",
    l = function() {
      var a = this,
        b =
          arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}
      Object.entries(b)
        .filter(function(a) {
          var b = h(a, 1),
            c = b[0]
          return c !== "allotParams" && c !== "complete"
        })
        .map(function(b) {
          var c = h(b, 2),
            d = c[0],
            e = c[1]
          a["" + k + d] = e
        })
      return this
    },
    m = {
      allotParams: "'allotParams' must be a function",
      boot: "`Injector failed to boot up `",
      module: "'module' must be a function or class",
    },
    n = new Proxy(
      {},
      {
        get: function c(a, b) {
          return function(a) {
            return m[b] || a + " Error"
          }
        },
      },
    ),
    o = new Proxy(
      {},
      {
        get: function c(a, b) {
          return function(a) {
            throw new Error(n[b](a))
          }
        },
      },
    ),
    p = new Proxy(
      {},
      {
        get: function c(a, b) {
          return new Map(
            ["initial", "initialized", "booting", "ready"].map(function(a) {
              return [a, a]
            }),
          ).get(b)
        },
      },
    ),
    q = (function() {
      function a() {
        var c =
          arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}
        f(this, a)
        var d = c.allotParams,
          e = d === undefined ? this._allotParams : d
        b.function(e) ? e.call(this, c) : o.allotParams()
        this._modules = new Map()
        this._queueModules = new Set()
        this._loadModulesHistory = new Set()
        this._bootstrap(c).then(this._complete.bind(this))
      }
      g(a, [
        {
          key: "_allotParams",
          value: function b(a) {
            return l.call(this, a)
          },
        },
        {
          key: "_complete",
          value: function c(a) {
            var d = a.done
            this.initiated = !0
            return b.function(d) && d(this.initiated)
          },
        },
        {
          key: "_merge",
          value: function b(a) {
            var c = []
            a.forEach(function() {
              var a =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {},
                b = a.injectors,
                d = arguments[1],
                e = b.reduce(function(a, b) {
                  var c = b.deps,
                    d = c === undefined ? [] : c
                  return [].concat(j(new Set(a.concat(d))))
                }, [])
              c.push({ moduleName: d, dependence: e })
            })
            return c
          },
        },
        {
          key: "_queue",
          value: function a() {
            var b =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : [],
              c = arguments[1],
              d = []
            b.map(function() {
              var a =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {},
                b = a.moduleName,
                e = a.dependence,
                f = e === undefined ? [] : e,
                g = f.length === 0,
                h = []
                  .concat(j(new Set(f.concat([].concat(j(c))))))
                  .filter(function(a) {
                    return ![].concat(j(c)).includes(a)
                  }),
                i = h.length === 0
              g || i ? c.add(b) : d.push({ moduleName: b, dependence: f })
            })
            d.length > 0 && this._queue(d, c)
          },
        },
        {
          key: "_initialize",
          value: function a() {
            var b = this,
              c = this._merge(this._modules)
            this._queue(c, this._queueModules)
            this._queueModules.forEach(function(a) {
              var c = b._modules.get(a),
                d = c.Module,
                e = c.parameters,
                f = c.moduleKey
              b[f] = new d(e)
              b[f].__status = p.initialized
            })
            this.distribute.call(this, c)
            return this
          },
        },
        {
          key: "_insureUnique",
          value: function a() {
            var c = this,
              d = [].concat(j(this._loadModulesHistory)).slice(0, -1)
            d.forEach(function() {
              var a =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : []
              return a.forEach(function(a) {
                var d = a.key,
                  e = a.module,
                  f =
                    c._modules.get(e.prototype.constructor.name).moduleKey !== d
                !b.null(d) &&
                  !b.undefined(d) &&
                  f &&
                  Reflect.deleteProperty(c, d)
              })
            })
          },
        },
        {
          key: "_bootstrap",
          value: async function d(a) {
            var f = this
            await c()
            this._insureUnique()
            try {
              var g = [].concat(j(this._queueModules))
              while (g.length > 0) {
                var h = g.shift(),
                  i = this._modules.get(h),
                  k = i.injectors,
                  l = i.moduleKey
                if (!this[l]) {
                  o.throw(l)
                  continue
                }
                var m = b.asyncFunction(this[l].initialize),
                  n = [].concat(j(k)),
                  q = n.filter(function(a) {
                    var b = a.before
                    return b
                  })
                this[l].__status = p.booting
                while (q.length > 0) {
                  var r = void 0,
                    s = q.shift(),
                    t = s.before,
                    u = s.deps,
                    v = b.asyncFunction(t),
                    w = u.map(function(a) {
                      return f[f._modules.get(a).moduleKey]
                    })
                  v
                    ? (r = await t.apply(undefined, j(w).concat([this[l]])))
                    : (r = t.apply(undefined, j(w).concat([this[l]])))
                }
                m
                  ? await this[l].initialize()
                  : b.function(this[l].initialize) && this[l].initialize()
                var x = n.filter(function(a) {
                  var b = a.after
                  return b
                })
                while (x.length > 0) {
                  var y = void 0,
                    z = x.shift(),
                    A = z.after,
                    u = z.deps,
                    B = b.asyncFunction(A),
                    C = u.map(function(a) {
                      return f[f._modules.get(a).moduleKey]
                    })
                  B
                    ? (y = await A.apply(undefined, j(C).concat([this[l]])))
                    : (y = A.apply(undefined, j(C).concat([this[l]])))
                }
                this[l].__status = p.ready
              }
            } catch (a) {
              console.log(a), o.boot()
            }
            return a
          },
        },
        {
          key: "inject",
          value: function c(a) {
            var d = this
            a.map(function() {
              var a =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {},
                c = a.module,
                e = a.deps,
                f = e === undefined ? [] : e,
                g = a.params,
                h = g === undefined ? {} : g,
                i = a.key,
                k = a.before,
                l = a.after
              if (!b.function(c)) {
                return o.module()
              }
              var m = c.prototype.constructor.name,
                n = c._key,
                p = n === undefined ? m : n,
                q = c._injectors,
                r = q === undefined ? [] : q,
                s = i || p,
                t = d._modules.get(m),
                u = t || {},
                v = u.parameters,
                w = v === undefined ? h : v,
                x = u.injectors,
                y = x === undefined ? r : x,
                z = {}
              t &&
                (z = {
                  parameters: h,
                  injectors: [].concat(j(r), [
                    { deps: f, before: k, after: l },
                  ]),
                })
              d._modules.set(
                m,
                Object.assign(
                  {
                    Module: c,
                    moduleKey: s,
                    parameters: Object.assign(w, h),
                    injectors: [].concat(j(y), [
                      { deps: f, before: k, after: l },
                    ]),
                  },
                  z,
                ),
              )
            })
            this._loadModulesHistory.add(a)
            this._initialize()
            return this
          },
        },
        {
          key: "distribute",
          value: function b(a) {
            var c = this
            a.map(function(a) {
              var b = a.moduleName,
                d = a.dependence
              d.map(function(a) {
                var d = c._modules.get(b),
                  e = d.moduleKey,
                  f = c._modules.get(a)
                c[e]["" + k + f.moduleKey] = c[e]
              })
            })
            return this
          },
        },
      ])
      return a
    })(),
    r = (function() {
      function a(c) {
        f(this, a)
        var d = b.function(this._allotParams)
        d ? this._allotParams(c) : o.allotParams()
        this.__status = p.initial
      }
      g(a, [
        {
          key: "_allotParams",
          value: function b(a) {
            return l.call(this, a)
          },
        },
      ])
      return a
    })(),
    s = function() {
      var a =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}
      return function(b) {
        b._injectors = [].concat(j(b._injectors || []), [a])
        a.key && (b._key = a.key)
      }
    },
    t = { Injector: q, Module: r, Decorator: s }
  a["default"] = t
  a.Injector = q
  a.Module = r
  a.Decorator = s
  Object.defineProperty(a, "__esModule", { value: !0 })
})
//# sourceMappingURL=glaive.min.js.map
