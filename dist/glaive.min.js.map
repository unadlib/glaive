{"version":3,"file":"glaive.min.js","sources":["../lib/isType.js","../lib/sleep.js","../lib/allot.js","../src/Injector.js","../src/Module.js","../src/Decorator.js","../src/index.js"],"sourcesContent":["export default new Proxy(\n  {},\n  {\n    get: (target, name) => value => {\n      const type = value::Object.prototype.toString().slice(8, -1)\n      return type[0].toLowerCase() + type.slice(1) === name\n    }\n  },\n)\n","export default async time => {\n  return await new Promise(resolve => {\n    if (!time) {\n      resolve(true)\n    } else {\n      setTimeout(() => resolve(true), time)\n    }\n  })\n}\n","export const prefix = \"_\"\nexport default function(config = {}) {\n  Object.entries(config)\n    .filter(([key]) => key !== \"allotParams\" && key !== \"complete\")\n    .map(([key, value]) => {\n      this[`${prefix}${key}`] = value\n    })\n  return this\n}\n","import is from \"../lib/isType\"\nimport sleep from \"../lib/sleep\"\nimport allot, { prefix } from \"../lib/allot\"\n\nexport default class Injector {\n  constructor(config = {}) {\n    const { allotParams = this._allotParams } = config\n    if (is.Function(allotParams)) {\n      ;this::allotParams(config)\n    } else {\n      throw new Error(`\\'allotParams\\' must be a function.`)\n    }\n    this._modules = new Map()\n    this._queueModules = new Set()\n    this._bootstrap(config).then(this::this._complete)\n  }\n\n  _allotParams(config) {\n    return this::allot(config)\n  }\n\n  _complete({ done }) {\n    this.initiated = true\n    is.function(done) && done(this.initiated)\n  }\n\n  _merge(modules) {\n    let dependenceMap = []\n    modules.forEach(({ injectors } = {}, moduleName) => {\n      const dependence = injectors.reduce((pre, { deps = [] }) => {\n        return [...new Set(pre.concat(deps))]\n      }, [])\n      dependenceMap.push({\n        moduleName,\n        dependence,\n      })\n    })\n    return dependenceMap\n  }\n\n  _queue(modules = [], list) {\n    let restModules = []\n    modules.map(({ moduleName, dependence = [] } = {}) => {\n      const isNoneDependence = dependence.length === 0\n      const rest = [...new Set(dependence.concat([...list]))].filter(\n        item => ![...list].includes(item),\n      )\n      const isDepended = rest.length === 0\n      if (isNoneDependence || isDepended) {\n        list.add(moduleName)\n      } else {\n        restModules.push({ moduleName, dependence })\n      }\n    })\n    if (restModules.length > 0) {\n      this._queue(restModules, list)\n    }\n  }\n\n  _initialize() {\n    const dependenceMap = this._merge(this._modules)\n    this._queue(dependenceMap, this._queueModules)\n    this._queueModules.forEach(moduleName => {\n      const { Module, parameters } = this._modules.get(moduleName)\n\n      this[moduleName] = new Module(parameters)\n    })\n    ;this::this.distribute(dependenceMap)\n    return this\n  }\n\n  async _bootstrap(config) {\n    await sleep()\n    try {\n      let queueModules = [...this._queueModules]\n      while (queueModules.length > 0) {\n        const moduleName = queueModules.shift()\n        const current = this._modules.get(moduleName)\n        const isAsync = is.asyncFunction(this[moduleName].initialize)\n        const injectors = [...current.injectors]\n        let beforeInjectors = injectors.filter(({ before }) => before)\n        while (beforeInjectors.length > 0) {\n          let unprocessed\n          const { before, deps } = beforeInjectors.shift()\n          const isAsyncAction = is.asyncFunction(before)\n          const args = deps.map(dep => this[dep])\n          if (isAsyncAction) {\n            unprocessed = await before(...args, this[moduleName])\n          } else {\n            unprocessed = before(...args, this[moduleName])\n          }\n        }\n        if (isAsync) {\n          await this[moduleName].initialize()\n        } else {\n          if (is.Function(this[moduleName].initialize)) {\n            this[moduleName].initialize()\n          }\n        }\n        let afterInjectors = injectors.filter(({ after }) => after)\n        while (afterInjectors.length > 0) {\n          let processed\n          const { after, deps } = afterInjectors.shift()\n          const isAsyncAction = is.asyncFunction(after)\n          const args = deps.map(dep => this[dep])\n          if (isAsyncAction) {\n            processed = await after(...args, this[moduleName])\n          } else {\n            processed = after(...args, this[moduleName])\n          }\n        }\n      }\n    } catch (e) {\n      throw new Error(`Injector failed to boot up. `)\n    }\n    return config\n  }\n\n  inject(models) {\n    models.map(({ module, deps = [], params = {}, before, after } = {}) => {\n      const { name, _injectors = [] } = module\n      const { parameters = params, injectors = _injectors } =\n        this._modules.get(name) || {}\n      this._modules.set(name, {\n        Module: module,\n        parameters: Object.assign(parameters, params),\n        injectors: [...injectors, { deps, before, after }],\n      })\n    })\n    this._initialize()\n    return this\n  }\n\n  distribute(dependenceMap) {\n    dependenceMap.map(({ moduleName, dependence }) => {\n      dependence.map(name => {\n        this[moduleName][`${prefix}${name}`] = this[moduleName]\n      })\n    })\n    return this\n  }\n}\n","import is from \"../lib/isType\"\nimport allot from \"../lib/allot\"\n\nexport default class Module {\n  constructor(args) {\n    const isFunction = is.function(this._allotParams)\n    if (isFunction) {\n      this._allotParams(args)\n    } else {\n      throw new Error('\"_allotParams\" must be a function')\n    }\n  }\n\n  _allotParams(config) {\n    return this::allot(config)\n  }\n}\n","export default (dependencies = {}) => target => {\n  target._injectors = [...(target._injectors || []), dependencies]\n}\n\n// export const prefix = '$$'\n// export const allot = (target, key, descriptor) => {\n//   const method = descriptor.value\n//   const allotParams = function(config = {}) {\n//     Object.entries(config)\n//       .filter(([key]) => key !== 'allotParams' && key !== 'complete')\n//       .map(([key, value]) => {\n//         console.log(key)\n//         this[`${prefix}${key}`] = value\n//       })\n//   }\n//   descriptor.value = (...args) => {\n//     const [config] = args\n//     return target::allotParams(config)\n//   }\n//   return descriptor\n// }\n","import Injector from \"./Injector\"\nimport Module from \"./Module\"\nimport Decorator from \"./Decorator\"\n\nexport default {\n  Injector,\n  Module,\n  Decorator,\n}\n\nexport { Injector, Module, Decorator }\n"],"names":["Proxy","target","name","type","Object","prototype","toString","slice","toLowerCase","time","Promise","resolve","prefix","config","entries","filter","key","map","value","Injector","allotParams","_allotParams","is","Function","Error","_modules","Map","_queueModules","Set","_bootstrap","then","_complete","allot","done","initiated","function","modules","dependenceMap","forEach","injectors","moduleName","dependence","reduce","pre","deps","concat","push","list","restModules","isNoneDependence","length","rest","includes","item","isDepended","add","_queue","_merge","_this","get","Module","parameters","distribute","sleep","queueModules","shift","current","isAsync","asyncFunction","initialize","beforeInjectors","before","unprocessed","isAsyncAction","args","_this2","dep","afterInjectors","after","processed","e","models","module","params","_injectors","_this3","set","assign","_initialize","_this4","isFunction","dependencies"],"mappings":"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"}