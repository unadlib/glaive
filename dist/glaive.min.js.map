{"version":3,"file":"glaive.min.js","sources":["../lib/isType.js","../lib/sleep.js","../lib/allot.js","../lib/error.js","../lib/moduleStatus.js","../src/Injector.js","../src/Module.js","../src/Decorator.js","../src/index.js"],"sourcesContent":["export default new Proxy(\n  {},\n  {\n    get: (target, name) => value => {\n      const type = value::Object.prototype.toString().slice(8, -1)\n      return type[0].toLowerCase() + type.slice(1) === name\n    },\n  },\n)\n","export default async time =>\n  await new Promise(resolve => {\n    if (!time) {\n      resolve(true)\n    } else {\n      setTimeout(() => resolve(true), time)\n    }\n  })\n","export const prefix = \"_\"\nexport default function(config = {}) {\n  Object.entries(config)\n    .filter(([key]) => key !== \"allotParams\" && key !== \"complete\")\n    .map(([key, value]) => {\n      this[`${prefix}${key}`] = value\n    })\n  return this\n}\n","export const ERROR = {\n  allotParams: `\\'allotParams\\' must be a function`,\n  boot: `\\`Injector failed to boot up \\``,\n  module: `\\'module\\' must be a function or class`,\n}\n\nconst error = new Proxy(\n  {},\n  {\n    get: (target, name) => value => {\n      return ERROR[name] || `${value} Error`\n    },\n  },\n)\n\nexport default new Proxy(\n  {},\n  {\n    get: (target, name) => value => {\n      throw new Error(error[name](value))\n    },\n  },\n)\n","export default new Proxy(\n  {},\n  {\n    get: (target, name) => {\n      return new Map(\n        [\"initial\", \"initialized\", \"booting\", \"ready\"].map(i => [i, i]),\n      ).get(name)\n    },\n  },\n)\n","import is from '../lib/isType'\nimport sleep from '../lib/sleep'\nimport allot, { prefix } from '../lib/allot'\nimport error from '../lib/error'\nimport moduleStatus from '../lib/moduleStatus'\n\nexport default (TargetModule = class {constructor() {}}) => {\n  return class Injector extends TargetModule {\n    constructor(config = {}) {\n      super(config)\n      const {allotParams = this._allotParams} = config\n      if (is.function(allotParams)) {\n        this::allotParams(config)\n      } else {\n        error.allotParams()\n      }\n      this._modules = new Map()\n      this._queueModules = new Set()\n      this._loadModulesHistory = new Set()\n      this._bootstrap(config).then(this::this._complete)\n    }\n\n    _allotParams(config) {\n      return this::allot(config)\n    }\n\n    _complete({done}) {\n      this.initiated = true\n      return is.function(done) && done(this.initiated)\n    }\n\n    _merge(modules) {\n      let dependenceMap = []\n      modules.forEach(({injectors} = {}, moduleName) => {\n        const dependence = injectors.reduce((pre, {deps = []}) => {\n          return [...new Set(pre.concat(deps))]\n        }, [])\n        dependenceMap.push({\n          moduleName,\n          dependence,\n        })\n      })\n      return dependenceMap\n    }\n\n    _queue(modules = [], list) {\n      let restModules = []\n      modules.map(({moduleName, dependence = []} = {}) => {\n        const isNoneDependence = dependence.length === 0\n        const rest = [...new Set(dependence.concat([...list]))].filter(\n          item => ![...list].includes(item),\n        )\n        const isDepended = rest.length === 0\n        if (isNoneDependence || isDepended) {\n          list.add(moduleName)\n        } else {\n          restModules.push({moduleName, dependence})\n        }\n      })\n      if (restModules.length > 0) {\n        this._queue(restModules, list)\n      }\n    }\n\n    _initialize() {\n      const dependenceMap = this._merge(this._modules)\n      this._queue(dependenceMap, this._queueModules)\n      this._queueModules.forEach(moduleName => {\n        const {Module, parameters, moduleKey, injectors} = this._modules.get(moduleName)\n        // const dependences = new Set(\n        //   injectors.reduce((prev,{deps=[]})=>{\n        //     return [...prev,...deps]\n        //   },[])\n        // )\n        // const dependenceModules = {}\n        // dependences.forEach((name)=>{\n        //   const {moduleKey} = this._modules.get(name)\n        //   dependenceModules[moduleKey] = this[moduleKey]\n        // })\n        // this[moduleKey] = new Module({...parameters,...dependenceModules})\n        this[moduleKey] = new Module(parameters)\n        this.mountParams(moduleKey)\n        this[moduleKey].__status = moduleStatus.initialized\n      })\n      this::this.distribute(dependenceMap)\n      return this\n    }\n\n    _insureUnique() {\n      const overloadModules = [...this._loadModulesHistory].slice(0, -1)\n      overloadModules.forEach((modules = []) =>\n        modules.forEach(({key, module}) => {\n          const isRemove =\n            this._modules.get(module.prototype.constructor.name).moduleKey !== key\n          if (!is.null(key) && !is.undefined(key) && isRemove) {\n            Reflect.deleteProperty(this, key)\n          }\n        }),\n      )\n    }\n\n    mountParams() {\n      return this\n    }\n\n    inject(modules, {preInject} = {}) {\n      preInject && this::preInject()\n      modules.map(\n        ({module, deps = [], params = {}, key, before, after} = {}) => {\n          if (!is.function(module)) {\n            return error.module()\n          }\n          const moduleName = module.prototype.constructor.name\n          const {_key = moduleName, _injectors = []} = module\n          const moduleKey = key || _key\n          const originModule = this._modules.get(moduleName)\n          const {parameters = params, injectors = _injectors} =\n          originModule || {}\n          let override = {}\n          if (originModule) {\n            override = {\n              parameters: params,\n              injectors: [..._injectors, {deps, before, after}],\n            }\n          }\n          this._modules.set(\n            moduleName,\n            Object.assign(\n              {\n                Module: module,\n                moduleKey: moduleKey[0].toLowerCase() + moduleKey.slice(1),\n                parameters: Object.assign(parameters, params),\n                injectors: [...injectors, {deps, before, after}],\n              },\n              override,\n            ),\n          )\n        },\n      )\n      this._loadModulesHistory.add(modules)\n      this._initialize()\n      return this\n    }\n\n    distribute(dependenceMap) {\n      dependenceMap.map(({moduleName, dependence}) => {\n        dependence.map(name => {\n          const {moduleKey} = this._modules.get(moduleName)\n          const module = this._modules.get(name)\n          this[moduleKey][`${prefix}${module.moduleKey}`] = this[module.moduleKey]\n        })\n      })\n      return this\n    }\n\n    async _bootstrap(config) {\n      await sleep()\n      this._insureUnique()\n      try {\n        let queueModules = [...this._queueModules]\n        while (queueModules.length > 0) {\n          const moduleName = queueModules.shift()\n          const {injectors, moduleKey} = this._modules.get(moduleName)\n          if (!this[moduleKey]) {\n            error.throw(moduleKey)\n            continue\n          }\n          const isAsync = is.asyncFunction(this[moduleKey].initialize)\n          const _injectors = [...injectors]\n          this[moduleKey].__status = moduleStatus.booting\n          let beforeInjectors = _injectors.filter(({before}) => before)\n          while (beforeInjectors.length > 0) {\n            let unprocessed\n            const {before, deps} = beforeInjectors.shift()\n            const isAsyncAction = is.asyncFunction(before)\n            const args = deps.map(dep => this[this._modules.get(dep).moduleKey])\n            if (isAsyncAction) {\n              unprocessed = await before(...args, this[moduleKey])\n            } else {\n              unprocessed = before(...args, this[moduleKey])\n            }\n          }\n          if (isAsync) {\n            await this[moduleKey].initialize()\n          } else {\n            if (is.function(this[moduleKey].initialize)) {\n              this[moduleKey].initialize()\n            }\n          }\n          let afterInjectors = _injectors.filter(({after}) => after)\n          while (afterInjectors.length > 0) {\n            let processed\n            const {after, deps} = afterInjectors.shift()\n            const isAsyncAction = is.asyncFunction(after)\n            const args = deps.map(dep => this[this._modules.get(dep).moduleKey])\n            if (isAsyncAction) {\n              processed = await after(...args, this[moduleKey])\n            } else {\n              processed = after(...args, this[moduleKey])\n            }\n          }\n          this[moduleKey].__status = moduleStatus.ready\n        }\n      } catch (e) {\n        console.log(e)\n        error.boot()\n      }\n      return config\n    }\n\n  }\n}\n","import is from \"../lib/isType\"\nimport allot from \"../lib/allot\"\nimport error from \"../lib/error\"\nimport moduleStatus from \"../lib/moduleStatus\"\n\nexport default class Module {\n  constructor(args) {\n    const isFunction = is.function(this._allotParams)\n    if (isFunction) {\n      this._allotParams(args)\n    } else {\n      error.allotParams()\n    }\n    this.__status = moduleStatus.initial\n  }\n\n  _allotParams(config) {\n    return this::allot(config)\n  }\n}\n","export default (dependencies = {}) => target => {\n  target._injectors = [...(target._injectors || []), dependencies]\n  if (dependencies.key) {\n    target._key = dependencies.key\n  }\n}\n\n// export const prefix = '$$'\n// export const allot = (target, key, descriptor) => {\n//   const method = descriptor.value\n//   const allotParams = function(config = {}) {\n//     Object.entries(config)\n//       .filter(([key]) => key !== 'allotParams' && key !== 'complete')\n//       .map(([key, value]) => {\n//         this[`${prefix}${key}`] = value\n//       })\n//   }\n//   descriptor.value = (...args) => {\n//     const [config] = args\n//     return target::allotParams(config)\n//   }\n//   return descriptor\n// }\n","import Injector from \"./Injector\"\nimport Module from \"./Module\"\nimport Decorator from \"./Decorator\"\n\nexport default {\n  Injector,\n  Module,\n  Decorator,\n}\n\nexport { Injector, Module, Decorator }\n"],"names":["Proxy","target","name","type","Object","prototype","toString","slice","toLowerCase","time","Promise","resolve","prefix","config","entries","filter","key","map","value","ERROR","error","Error","Map","i","get","TargetModule","allotParams","_this","_allotParams","is","function","_modules","_queueModules","Set","_loadModulesHistory","_bootstrap","then","_complete","allot","done","initiated","modules","dependenceMap","forEach","injectors","moduleName","dependence","reduce","pre","deps","concat","push","list","restModules","isNoneDependence","length","rest","includes","item","isDepended","add","_queue","_merge","_this2","Module","parameters","moduleKey","mountParams","__status","moduleStatus","initialized","distribute","overloadModules","module","isRemove","_this3","constructor","null","undefined","deleteProperty","preInject","params","before","after","_key","_injectors","originModule","_this4","override","set","assign","_initialize","_this5","sleep","_insureUnique","queueModules","shift","throw","isAsync","asyncFunction","initialize","booting","beforeInjectors","unprocessed","isAsyncAction","args","_this6","dep","afterInjectors","processed","ready","e","log","boot","isFunction","initial","dependencies"],"mappings":"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"}