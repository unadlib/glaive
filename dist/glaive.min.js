!(function(a, b) {
  typeof exports === "object" && typeof module !== "undefined"
    ? b(exports)
    : typeof define === "function" && define.amd
      ? define(["exports"], b)
      : b((a.glaive = {}))
})(this, function(a) {
  "use strict"
  var b = new Proxy(
      {},
      {
        get: function c(a, b) {
          return function(a) {
            var c = Object.prototype.toString.call(a).slice(8, -1)
            return c[0].toLowerCase() + c.slice(1) === b
          }
        },
      },
    ),
    c = async function(a) {
      return await new Promise(function(b) {
        a
          ? setTimeout(function() {
              return b(!0)
            }, a)
          : b(!0)
      })
    },
    f = function(a, b) {
      if (!(a instanceof b)) {
        throw new TypeError("Cannot call a class as a function")
      }
    },
    g = (function() {
      function a(a, b) {
        for (var c = 0; c < b.length; c++) {
          var d = b[c]
          d.enumerable = d.enumerable || !1
          d.configurable = !0
          "value" in d && (d.writable = !0)
          Object.defineProperty(a, d.key, d)
        }
      }
      return function(b, c, d) {
        c && a(b.prototype, c)
        d && a(b, d)
        return b
      }
    })(),
    h = (function() {
      function a(a, b) {
        var c = [],
          d = !0,
          e = !1,
          f = undefined
        try {
          for (
            var g = a[Symbol.iterator](), h;
            !(d = (h = g.next()).done);
            d = !0
          ) {
            c.push(h.value)
            if (b && c.length === b) break
          }
        } catch (a) {
          ;(e = !0), (f = a)
        } finally {
          try {
            !d && g["return"] && g["return"]()
          } finally {
            if (e) throw f
          }
        }
        return c
      }
      return function(b, c) {
        if (Array.isArray(b)) {
          return b
        } else if (Symbol.iterator in Object(b)) {
          return a(b, c)
        } else {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance",
          )
        }
      }
    })(),
    j = function(a) {
      if (Array.isArray(a)) {
        for (var b = 0, c = Array(a.length); b < a.length; b++) c[b] = a[b]
        return c
      } else {
        return Array.from(a)
      }
    },
    k = "_",
    l = function() {
      var a = this,
        b =
          arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}
      Object.entries(b)
        .filter(function(a) {
          var b = h(a, 1),
            c = b[0]
          return c !== "allotParams" && c !== "complete"
        })
        .map(function(b) {
          var c = h(b, 2),
            d = c[0],
            e = c[1]
          a["" + k + d] = e
        })
      return this
    },
    m = (function() {
      function a() {
        var c =
          arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}
        f(this, a)
        var d = c.allotParams,
          e = d === undefined ? this._allotParams : d
        if (b.Function(e)) e.call(this, c)
        else {
          throw new Error("'allotParams' must be a function.")
        }
        this._modules = new Map()
        this._queueModules = new Set()
        this._bootstrap(c).then(this._complete.bind(this))
      }
      g(a, [
        {
          key: "_allotParams",
          value: function b(a) {
            return l.call(this, a)
          },
        },
        {
          key: "_complete",
          value: function c(a) {
            var d = a.done
            this.initiated = !0
            b.function(d) && d(this.initiated)
          },
        },
        {
          key: "_merge",
          value: function b(a) {
            var c = []
            a.forEach(function() {
              var a =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {},
                b = a.injectors,
                d = arguments[1],
                e = b.reduce(function(a, b) {
                  var c = b.deps,
                    d = c === undefined ? [] : c
                  return [].concat(j(new Set(a.concat(d))))
                }, [])
              c.push({ moduleName: d, dependence: e })
            })
            return c
          },
        },
        {
          key: "_queue",
          value: function a() {
            var b =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : [],
              c = arguments[1],
              d = []
            b.map(function() {
              var a =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {},
                b = a.moduleName,
                e = a.dependence,
                f = e === undefined ? [] : e,
                g = f.length === 0,
                h = []
                  .concat(j(new Set(f.concat([].concat(j(c))))))
                  .filter(function(a) {
                    return ![].concat(j(c)).includes(a)
                  }),
                i = h.length === 0
              g || i ? c.add(b) : d.push({ moduleName: b, dependence: f })
            })
            d.length > 0 && this._queue(d, c)
          },
        },
        {
          key: "_initialize",
          value: function a() {
            var b = this,
              c = this._merge(this._modules)
            this._queue(c, this._queueModules)
            this._queueModules.forEach(function(a) {
              var c = b._modules.get(a),
                d = c.Module,
                e = c.parameters
              b[a] = new d(e)
            })
            this.distribute.call(this, c)
            return this
          },
        },
        {
          key: "_bootstrap",
          value: async function d(a) {
            var f = this
            await c()
            try {
              var g = [].concat(j(this._queueModules))
              while (g.length > 0) {
                var h = g.shift(),
                  i = this._modules.get(h),
                  k = b.asyncFunction(this[h].initialize),
                  l = [].concat(j(i.injectors)),
                  m = l.filter(function(a) {
                    var b = a.before
                    return b
                  })
                while (m.length > 0) {
                  var n = void 0,
                    o = m.shift(),
                    p = o.before,
                    q = o.deps,
                    r = b.asyncFunction(p),
                    s = q.map(function(a) {
                      return f[a]
                    })
                  r
                    ? (n = await p.apply(undefined, j(s).concat([this[h]])))
                    : (n = p.apply(undefined, j(s).concat([this[h]])))
                }
                k
                  ? await this[h].initialize()
                  : b.Function(this[h].initialize) && this[h].initialize()
                var t = l.filter(function(a) {
                  var b = a.after
                  return b
                })
                while (t.length > 0) {
                  var u = void 0,
                    v = t.shift(),
                    w = v.after,
                    q = v.deps,
                    x = b.asyncFunction(w),
                    y = q.map(function(a) {
                      return f[a]
                    })
                  x
                    ? (u = await w.apply(undefined, j(y).concat([this[h]])))
                    : (u = w.apply(undefined, j(y).concat([this[h]])))
                }
              }
            } catch (a) {
              throw new Error("Injector failed to boot up. ")
            }
            return a
          },
        },
        {
          key: "inject",
          value: function b(a) {
            var c = this
            a.map(function() {
              var a =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {},
                b = a.module,
                d = a.deps,
                e = d === undefined ? [] : d,
                f = a.params,
                g = f === undefined ? {} : f,
                h = a.before,
                i = a.after,
                k = b.name,
                l = b._injectors,
                m = l === undefined ? [] : l,
                n = c._modules.get(k) || {},
                o = n.parameters,
                p = o === undefined ? g : o,
                q = n.injectors,
                r = q === undefined ? m : q
              c._modules.set(k, {
                Module: b,
                parameters: Object.assign(p, g),
                injectors: [].concat(j(r), [{ deps: e, before: h, after: i }]),
              })
            })
            this._initialize()
            return this
          },
        },
        {
          key: "distribute",
          value: function b(a) {
            var c = this
            a.map(function(a) {
              var b = a.moduleName,
                d = a.dependence
              d.map(function(a) {
                c[b]["" + k + a] = c[b]
              })
            })
            return this
          },
        },
      ])
      return a
    })(),
    n = (function() {
      function a(c) {
        f(this, a)
        var d = b.function(this._allotParams)
        if (d) this._allotParams(c)
        else {
          throw new Error('"_allotParams" must be a function')
        }
      }
      g(a, [
        {
          key: "_allotParams",
          value: function b(a) {
            return l.call(this, a)
          },
        },
      ])
      return a
    })(),
    o = function() {
      var a =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}
      return function(b) {
        b._injectors = [].concat(j(b._injectors || []), [a])
      }
    },
    p = { Injector: m, Module: n, Decorator: o }
  a["default"] = p
  a.Injector = m
  a.Module = n
  a.Decorator = o
  Object.defineProperty(a, "__esModule", { value: !0 })
})
//# sourceMappingURL=glaive.min.js.map
